import 'package:hive/hive.dart';

part 'market_price_model.g.dart';

@HiveType(typeId: 4)
class MarketPrice {
  @HiveField(0)
  final String id;
  
  @HiveField(1)
  final String cropName;
  
  @HiveField(2)
  final String marketName;
  
  @HiveField(3)
  final String state;
  
  @HiveField(4)
  final String district;
  
  @HiveField(5)
  final double minPrice;
  
  @HiveField(6)
  final double maxPrice;
  
  @HiveField(7)
  final double modalPrice;
  
  @HiveField(8)
  final String unit;
  
  @HiveField(9)
  final DateTime date;
  
  @HiveField(10)
  final DateTime lastUpdated;

  MarketPrice({
    required this.id,
    required this.cropName,
    required this.marketName,
    required this.state,
    required this.district,
    required this.minPrice,
    required this.maxPrice,
    required this.modalPrice,
    this.unit = 'Quintal',
    required this.date,
    required this.lastUpdated,
  });

  factory MarketPrice.fromJson(Map<String, dynamic> json) {
    return MarketPrice(
      id: json['id'] ?? '',
      cropName: json['crop_name'] ?? '',
      marketName: json['market_name'] ?? '',
      state: json['state'] ?? '',
      district: json['district'] ?? '',
      minPrice: json['min_price'] != null ? double.parse(json['min_price'].toString()) : 0.0,
      maxPrice: json['max_price'] != null ? double.parse(json['max_price'].toString()) : 0.0,
      modalPrice: json['modal_price'] != null ? double.parse(json['modal_price'].toString()) : 0.0,
      unit: json['unit'] ?? 'Quintal',
      date: json['date'] != null ? DateTime.parse(json['date']) : DateTime.now(),
      lastUpdated: json['last_updated'] != null ? DateTime.parse(json['last_updated']) : DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'crop_name': cropName,
      'market_name': marketName,
      'state': state,
      'district': district,
      'min_price': minPrice,
      'max_price': maxPrice,
      'modal_price': modalPrice,
      'unit': unit,
      'date': date.toIso8601String(),
      'last_updated': lastUpdated.toIso8601String(),
    };
  }
}

// This will be generated by Hive
class MarketPriceAdapter extends TypeAdapter<MarketPrice> {
  @override
  final int typeId = 4;

  @override
  MarketPrice read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return MarketPrice(
      id: fields[0] as String,
      cropName: fields[1] as String,
      marketName: fields[2] as String,
      state: fields[3] as String,
      district: fields[4] as String,
      minPrice: fields[5] as double,
      maxPrice: fields[6] as double,
      modalPrice: fields[7] as double,
      unit: fields[8] as String,
      date: fields[9] as DateTime,
      lastUpdated: fields[10] as DateTime,
    );
  }

  @override
  void write(BinaryWriter writer, MarketPrice obj) {
    writer
      ..writeByte(11)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.cropName)
      ..writeByte(2)
      ..write(obj.marketName)
      ..writeByte(3)
      ..write(obj.state)
      ..writeByte(4)
      ..write(obj.district)
      ..writeByte(5)
      ..write(obj.minPrice)
      ..writeByte(6)
      ..write(obj.maxPrice)
      ..writeByte(7)
      ..write(obj.modalPrice)
      ..writeByte(8)
      ..write(obj.unit)
      ..writeByte(9)
      ..write(obj.date)
      ..writeByte(10)
      ..write(obj.lastUpdated);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MarketPriceAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
