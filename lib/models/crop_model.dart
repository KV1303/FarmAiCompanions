import 'package:hive/hive.dart';

part 'crop_model.g.dart';

@HiveType(typeId: 2)
class Crop {
  @HiveField(0)
  final String id;
  
  @HiveField(1)
  final String name;
  
  @HiveField(2)
  final String scientificName;
  
  @HiveField(3)
  final int growthDuration; // in days
  
  @HiveField(4)
  final List<String> idealConditions;
  
  @HiveField(5)
  final double idealTemperatureMin;
  
  @HiveField(6)
  final double idealTemperatureMax;
  
  @HiveField(7)
  final double idealRainfallMin;
  
  @HiveField(8)
  final double idealRainfallMax;
  
  @HiveField(9)
  final String idealSoilType;
  
  @HiveField(10)
  final List<String> commonDiseases;
  
  @HiveField(11)
  final List<String> nutrientRequirements;

  Crop({
    required this.id,
    required this.name,
    required this.scientificName,
    required this.growthDuration,
    required this.idealConditions,
    required this.idealTemperatureMin,
    required this.idealTemperatureMax,
    required this.idealRainfallMin,
    required this.idealRainfallMax,
    required this.idealSoilType,
    required this.commonDiseases,
    required this.nutrientRequirements,
  });

  factory Crop.fromJson(Map<String, dynamic> json) {
    return Crop(
      id: json['id'] ?? '',
      name: json['name'] ?? '',
      scientificName: json['scientific_name'] ?? '',
      growthDuration: json['growth_duration'] ?? 0,
      idealConditions: json['ideal_conditions'] != null
          ? List<String>.from(json['ideal_conditions'])
          : [],
      idealTemperatureMin: json['ideal_temperature_min'] != null
          ? double.parse(json['ideal_temperature_min'].toString())
          : 0.0,
      idealTemperatureMax: json['ideal_temperature_max'] != null
          ? double.parse(json['ideal_temperature_max'].toString())
          : 0.0,
      idealRainfallMin: json['ideal_rainfall_min'] != null
          ? double.parse(json['ideal_rainfall_min'].toString())
          : 0.0,
      idealRainfallMax: json['ideal_rainfall_max'] != null
          ? double.parse(json['ideal_rainfall_max'].toString())
          : 0.0,
      idealSoilType: json['ideal_soil_type'] ?? '',
      commonDiseases: json['common_diseases'] != null
          ? List<String>.from(json['common_diseases'])
          : [],
      nutrientRequirements: json['nutrient_requirements'] != null
          ? List<String>.from(json['nutrient_requirements'])
          : [],
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'scientific_name': scientificName,
      'growth_duration': growthDuration,
      'ideal_conditions': idealConditions,
      'ideal_temperature_min': idealTemperatureMin,
      'ideal_temperature_max': idealTemperatureMax,
      'ideal_rainfall_min': idealRainfallMin,
      'ideal_rainfall_max': idealRainfallMax,
      'ideal_soil_type': idealSoilType,
      'common_diseases': commonDiseases,
      'nutrient_requirements': nutrientRequirements,
    };
  }
}

// This will be generated by Hive
class CropAdapter extends TypeAdapter<Crop> {
  @override
  final int typeId = 2;

  @override
  Crop read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return Crop(
      id: fields[0] as String,
      name: fields[1] as String,
      scientificName: fields[2] as String,
      growthDuration: fields[3] as int,
      idealConditions: (fields[4] as List).cast<String>(),
      idealTemperatureMin: fields[5] as double,
      idealTemperatureMax: fields[6] as double,
      idealRainfallMin: fields[7] as double,
      idealRainfallMax: fields[8] as double,
      idealSoilType: fields[9] as String,
      commonDiseases: (fields[10] as List).cast<String>(),
      nutrientRequirements: (fields[11] as List).cast<String>(),
    );
  }

  @override
  void write(BinaryWriter writer, Crop obj) {
    writer
      ..writeByte(12)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.name)
      ..writeByte(2)
      ..write(obj.scientificName)
      ..writeByte(3)
      ..write(obj.growthDuration)
      ..writeByte(4)
      ..write(obj.idealConditions)
      ..writeByte(5)
      ..write(obj.idealTemperatureMin)
      ..writeByte(6)
      ..write(obj.idealTemperatureMax)
      ..writeByte(7)
      ..write(obj.idealRainfallMin)
      ..writeByte(8)
      ..write(obj.idealRainfallMax)
      ..writeByte(9)
      ..write(obj.idealSoilType)
      ..writeByte(10)
      ..write(obj.commonDiseases)
      ..writeByte(11)
      ..write(obj.nutrientRequirements);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CropAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}
